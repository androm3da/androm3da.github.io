{"name":"Androm3da.GitHub.io","tagline":"","body":"## Clang\r\n\r\nI am impressed by `clang`, so I had a desire to learn more about its `libTooling`.  I figured it would be valuable to learn how to exploit this toolkit and it would make me a more effective promoter.\r\n\r\n`scan-build` is a static analysis utility from the `clang` suite.  It comes with a large set of pre-defined checks for catching various errors.  There is a plugin interface for `scan-build` that doesn't look too difficult to take advantage of.  That way teams can design their own checkers to suit their needs.  In fact, the llvm dev team has done just that -- created a `llvm.Conventions` checker for their team to verify that submissions conform to their development conventions.\r\n\r\nI've worked on large teams that span several countries.  Even with relatively well-described standards for coding, human code reviews don't always catch some classic errors that the standards are designed to catch.\r\n\r\nThe output of `scan-build` can be simple text at the command line or a handy HTML report.  The latter is easier to navigate for large code bases or reports that follow a tortuous path to the offending code.\r\n\r\nIf you're not interested in this article, you can [skip the prose and go straight to the code](https://github.com/androm3da/sample-checker).\r\n\r\n## Sample Problem\r\n\r\nFor CPU-bound performance critical code, a classic source of suboptimal code is when floating-point literals end up promoting some computation to use double-precision.\r\n\r\nHere's the difference between the code generated for `x * 100.` vs `x * 100.f`:\r\n\r\n    :::asm\r\n    float.o:     file format elf64-x86-64                           |  double.o:     file format elf64-x86-64\r\n     \r\n    \r\n    Disassembly of section .text:                                      Disassembly of section .text:\r\n    \r\n    0000000000000000 <transformInput>:                                 0000000000000000 <transformInput>:\r\n    \r\n                                                                    >\r\n    float transformInput(float x)                                      float transformInput(float x)\r\n    {                                                                  {\r\n       0:   55                      push   %rbp                           0:   55                      push   %rbp\r\n       1:   48 89 e5                mov    %rsp,%rbp                      1:   48 89 e5                mov    %rsp,%rbp\r\n       4:   48 b8 64 00 00 00 00    movabs $0x64,%rax                     4:   48 b8 64 00 00 00 00    movabs $0x64,%rax\r\n       b:   00 00 00                                                      b:   00 00 00 \r\n       e:   f3 48 0f 2a c8          cvtsi2ss %rax,%xmm1             |     e:   f2 48 0f 2a c8          cvtsi2sd %rax,%xmm1\r\n      13:   f3 0f 11 45 fc          movss  %xmm0,-0x4(%rbp)              13:   f3 0f 11 45 fc          movss  %xmm0,-0x4(%rbp)\r\n        return x * 100.f;                                           |      return x * 100.;\r\n      18:   f3 0f 10 45 fc          movss  -0x4(%rbp),%xmm0         |    18:   f3 0f 5a 45 fc          cvtss2sd -0x4(%rbp),%xmm0\r\n      1d:   f3 0f 59 c1             mulss  %xmm1,%xmm0              |    1d:   f2 0f 59 c1             mulsd  %xmm1,%xmm0\r\n      21:   5d                      pop    %rbp                     |    21:   f2 0f 5a c0             cvtsd2ss %xmm0,%xmm0\r\n      22:   c3                      retq                            |    25:   5d                      pop    %rbp\r\n\r\nThose extra `cvtsx2sx` instructions are required to promote the arithmetic to use double-precision.  For the most part, that work is useless because we convert back to single-precision for the return value.  This can cost us dearly if this code ends up in an inner loop.  So that pesky literal is very pernicious.\r\n\r\nThis problem is well known, so `gcc` already has a warning (`-Wdouble-promotion`) designed to be on the lookout for this.  Also, `-fsingle-precision-constant` exists to force the single-precision behavior.\r\n\r\nRegardless of the existing features, this seems like a simple enough use case to get my feet wet with writing a Clang Checker.\r\n\r\n## Building the checker library\r\n\r\nI started off with Ubuntu 14.04.1 (`trusty`) and `clang-3.5`.  Ubuntu's popularity practically guarantees me that someone else has tried this before me.  That said, I've also had some luck building from source on older platforms like SLES11 SP3.  I'll focus on ubuntu now because the process is significantly simpler.\r\n\r\nAfter encountering compilation errors with 3.5, I backed off to 3.4 and everything worked well.  Start with:\r\n\r\n    sudo apt-get install llvm-3.4-dev clang-3.4 libclang-3.4-dev\r\n\r\nI created a mostly-empty `Checker` that would emit a bug at almost any code I threw at it as a \"Hello World.\"  I tried to start with `cmake` for building the `Checker` but I ran into challenges there.  Since this was pretty much my first experience building something myself with `cmake` I decided that it wasn't critical.  I know GNU `make`, so I just shifted gears and created a `Makefile`.  If you need features only present on newer releases, I'd recommend just building from source where you likely won't encounter any of these problems.  You're also in a better position in getting support from the community than you are when you use Canonical's packages.  Note that you may find subtle incompatibilities among releases.\r\n\r\n    :::make\r\n    LLVM_VER:=3.4\r\n    LLVM_CXXFLAGS:=$(shell llvm-config-$(LLVM_VER) --cxxflags)\r\n    LLVM_LDFLAGS:=$(shell llvm-config-$(LLVM_VER) --ldflags --libs )\r\n    \r\n    CLANG_LIBS:= \\\r\n\t    -Wl,--start-group \\\r\n\t    -lclangAST \\\r\n\t    -lclangAnalysis \\\r\n\t    -lclangBasic \\\r\n\t    -lclangDriver \\\r\n\t    -lclangEdit \\\r\n\t    -lclangFrontend \\\r\n\t    -lclangFrontendTool \\\r\n\t    -lclangLex \\\r\n\t    -lclangParse \\\r\n\t    -lclangSema \\\r\n\t    -lclangEdit \\\r\n\t    -lclangASTMatchers \\\r\n\t    -lclangRewriteFrontend \\\r\n\t    -lclangStaticAnalyzerFrontend \\\r\n\t    -lclangStaticAnalyzerCheckers \\\r\n\t    -lclangStaticAnalyzerCore \\\r\n\t    -lclangSerialization \\\r\n\t    -lclangTooling \\\r\n\t    -Wl,--end-group \\\r\n        $()\r\n    \r\n    CXXFLAGS=-fno-rtti -Wall -g -std=c++11\r\n    \r\n    CXXFLAGS+=$(LLVM_CXXFLAGS)\r\n    LDFLAGS+=$(LLVM_LDFLAGS) -shared\r\n    \r\n    LOADLIBES+=-lstdc++\r\n    LOADLIBES+=$(CLANG_LIBS)\r\n    \r\n    libfloatcheck.so: float-check.o\r\n\t    $(CXX) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@\r\n\r\nHere's our simple checker to test the build:\r\n\r\n\r\n    :::c++\r\n    namespace {\r\n        class FloatExcessPrecisionChecker: public Checker <check::Bind,\r\n                                                            > \r\n        {\r\n            mutable std::unique_ptr<BugType> bugType;\r\n    \r\n            public:\r\n                FloatExcessPrecisionChecker() \r\n                    : bugType(new BugType(\"Excess floating-point precision\", \"androm3da analyzer\"))\r\n                {\r\n                }\r\n                \r\n                void checkBind(SVal \tLoc,\r\n                               SVal \tVal,\r\n                               const Stmt *Statement,\r\n                               CheckerContext &ctxt\r\n                               )\t\tconst;\r\n        };\r\n    } \r\n    \r\n    void FloatExcessPrecisionChecker::checkBind(SVal \tLoc,\r\n                           SVal \tVal,\r\n                           const Stmt *Statement,\r\n                           CheckerContext &ctxt\r\n                           )\t\tconst\r\n    {\r\n        ExplodedNode  *loc = ctxt.generateSink();\r\n    \r\n        BugReport *bug = new BugReport(*this->bugType, \"all bugs all the time\", loc);\r\n        ctxt.emitReport(bug);\r\n    }\r\n    \r\n    extern \"C\"\r\n    const char clang_analyzerAPIVersionString[] = CLANG_ANALYZER_API_VERSION_STRING;\r\n    \r\n    extern \"C\"\r\n    void clang_registerCheckers(CheckerRegistry &registry) {\r\n      registry.addChecker<FloatExcessPrecisionChecker>(\"performance.crit.ExcessPrecision\", \"float ...\");\r\n    }\r\n\r\nThe most interesting part so far is the `checkBind()` method inherited from `clang::ento::Checker<>`.  Our Checker's flow is primarily dictated by the specialization of the `Checker` we're inheriting from.  `check::Bind` hooks \"[binding of a value to a location](http://clang.llvm.org/doxygen/classclang_1_1ento_1_1CheckerDocumentation.html#a42aac3963fb75b8656ce38b10476e03f).\"  In my experience with vanilla test code, this is typically assignments.  The CheckerDocumentation is an excellent basis for understanding how your `Checker` is integrated with the overall ecosystem.\r\n\r\n`ctxt.generateSink()` tells the analyzer not to consider anything else in this path for this checker.\r\n\r\n## Taking a test drive\r\nWe can invoke our checker using `scan-build` or `clang`:\r\n\r\n    scan-build -load-plugin ~/src/floatcheck/libfloatcheck.so -enable-checker performance.crit.ExcessPrecision make -C test/ --always-make\r\n\r\nRunning this one yields the following output:\r\n\r\n    :::text\r\n    scan-build: Using '/usr/bin/clang' for static analysis\r\n    make[1]: Entering directory `/home/androm3da/src/floatcheck/test'\r\n    /usr/share/clang/scan-build/c++-analyzer    -c -o test_one.o test_one.cpp\r\n    test_one.cpp:28:2: warning: all bugs all the time\r\n            int j = i + 33.f;\r\n            ^~~~~\r\n    test_one.cpp:35:2: warning: all bugs all the time\r\n            int j = i + 100;\r\n            ^~~~~\r\n\r\n`scan-build` works similarly to some commercial static analysis tools in that it watches your build and deduces how to get the analysis in the correct context.  This is necessary for C/C++ because you can't even create the [AST](http://en.wikipedia.org/wiki/Abstract_syntax_tree) for a translation unit without the `define`s, `include`s and other compiler arguments.  It's valuable because `scan-build` might generate false positives or false negatives if it were used with a different context.\r\n\r\n## Designing a useful checker\r\n\r\n`checkBind` was a good sanity-check, perhaps useful if we wanted to look at all assignments.  But it's probably simpler to just zoom in on any floating point literals that we come across.  So we'll ditch the `check::Bind` and add a `check::PostStmt<FloatingLiteral>`.  This will invoke `checkPostStmt()`, so let's override that method to match:\r\n\r\n    :::C++\r\n    void FloatExcessPrecisionChecker::checkPostStmt(const FloatingLiteral *fl, CheckerContext &ctxt) const\r\n    {\r\n        const bool is_double =  &fl->getSemantics() == &APFloat::IEEEdouble;\r\n        const bool foundbug = is_double;\r\n    \r\n        if (foundbug)\r\n        {\r\n            ExplodedNode  *loc = ctxt.generateSink();\r\n    \r\n            BugReport *bug = new BugReport(*this->bugType, \r\n                    \"literal w/double precision, may impact performance\", loc);\r\n            ctxt.emitReport(bug);\r\n        }\r\n    }\r\n\r\nLet 'er rip on the test code:\r\n\r\n    :::text\r\n    scan-build: Using '/usr/bin/clang' for static analysis\r\n    make[1]: Entering directory `/home/androm3da/src/floatcheck/test'\r\n    /usr/share/clang/scan-build/c++-analyzer    -c -o test_one.o test_one.cpp\r\n    test_one.cpp:12:14: warning: literal w/double precision, may impact performance\r\n            int j = i + 100.;\r\n                        ^~~~\r\n\r\n\r\nOk, so we're in business.  But so far, we're not really exploiting the power of the checker.  Let's see if we can find a way to let folks intentionally use a `double`-precision literal without setting off our checker.  C++ has a pretty good mechanism of letting coders signify their intent for a type.  We'll (ab)use the explicit cast to suggest that this use of higher-precision literals is by design.\r\n\r\n    :::C++\r\n    void FloatExcessPrecisionChecker::checkPostStmt(const FloatingLiteral *fl, CheckerContext &ctxt) const\r\n    {\r\n        auto parents = ctxt.getASTContext().getParents(*fl);\r\n        const bool is_intentional = !parents.empty() \r\n            && parents[0].get<CXXStaticCastExpr>() != nullptr \r\n            && parents[0].get<CXXStaticCastExpr>()->getTypeAsWritten().getAsString() == \"double\";\r\n        const bool is_double =  &fl->getSemantics() == &APFloat::IEEEdouble;\r\n        const bool foundbug = !is_intentional && is_double;\r\n    \r\n        if (foundbug)\r\n        {\r\n            ExplodedNode  *loc = ctxt.generateSink();\r\n    \r\n            BugReport *bug = new BugReport(*this->bugType, \r\n                    \"literal w/double precision, may impact performance\", loc);\r\n            ctxt.emitReport(bug);\r\n        }\r\n    }\r\n\r\nA `FloatingLiteral` is-a `Stmt`, we look at its parents to determine whether the immediate parent is a `static_cast<>`.\r\n\r\nHere's our test case with an explicit cast:\r\n\r\n    :::C++\r\n    int some_intentional_dbl_func(int i) {\r\n\t    int j = i + static_cast<double>(100.);\r\n    \r\n\t    return j - 12;\r\n    }\r\n\r\nBut it doesn't trigger our warning, just as we'd like:\r\n\r\n    scan-build: Using '/usr/bin/clang' for static analysis\r\n    make[1]: Entering directory `/home/brian/src/floatcheck/test'\r\n    /usr/share/clang/scan-build/c++-analyzer    -c -o test_one.o test_one.cpp\r\n    test_one.cpp:12:14: warning: literal w/double precision, may impact performance\r\n            int j = i + 100.;\r\n                        ^~~~\r\n    1 warning generated.\r\n\r\n## Follow up, other notes\r\n\r\nI was able to whip up this example by doing a great deal of wandering around clang's API documentation.  It's an excellent resource.  The llvm, clang projects move really fast, sometimes without regard to backwards compatibility of these interfaces.  Although I didn't notice any incompatibilities between what's documented at http://clang.llvm.org/doxygen/ and the llvm-3.4 install that I used for this article.\r\n\r\nThis is still a pretty low complexity checker that you could probably get from AST analysis alone.  But it's a great starting point for further work.  We could expand our search to any high-precision operands or pass/return values.  Also, it would be useful to further narrow our search domain to only what the user considers performance critical code.  I'd like to only consider methods which are declared in classes which have a class with the name \"PerfCritical\" among its ancestors.  That way, builders could apply this checker globally and users can opt-in to the checker only where appropriate.\r\n\r\nIn searching for ancestors, I know I should probably try to get the `FunctionDecl` associated with this code.  But I couldn't find a way to get the associated `FunctionDecl` from the `Stmt`, `ASTContext`, etc values that I get at `checkPostStmt` or similar intercepts.  Assuming that there's no way to get there from here, an alternative is to build a list of violations found via `checkPostStmt` and use `CheckASTDecl` to find `FunctionDecl`s with a body and walk their children to match against `Stmt`s in our violation list.\r\n\r\nThose `generateSink()` calls are a handy way to get the appropriate location to highlight (necessary for the `BugReport`).  But their side-effect is to force the analyzer to stop searching this code path.  For this particular checker we'd probably prefer to continue our search.  I'll bet `ASTContext` or something similar has a way to get the `ExplodedNode` we need for `BugReport` without halting the search.\r\n\r\n## Appendix\r\n[^1] `fatal error: 'llvm/ADT/iterator_range.h' file not found` when including `StaticAnalyzer/Core/Checker.h`\r\n\r\n* Clang's [Checker documentation](http://clang.llvm.org/doxygen/classclang_1_1ento_1_1CheckerDocumentation.html)\r\n* a [checker used to find the heartbleed bug](https://github.com/awruef/find-heartbleed/)\r\n* [Eli Bendersky's samples of code to leverage llvm/clang](https://github.com/eliben/llvm-clang-samples/)\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}